<html>
<head>
<title>ΔMaze Amaze</title>
<link rel="stylesheet" type="text/css" href="main.css" media="all">
<script src="/socket.io/socket.io.js"></script>
<script>

  //var socket = io.connect('http://amaze.nodester.com'); 
  var socket = io.connect('http://localhost'); 


  //var name = prompt('What is your nickname?', 'Write your name');
  var connected = false;
  var mazeWriter = false;
  var inGame = false;

  socket.on('connect', function () {

    socket.on('ready', function() {
    	console.log("Please be patient; you'll be able to play as soon as an opponent arrives and joins your game!");
    });

    socket.on('startGameMAzeWriter', function(room) {
    	clearCanvas();
    	inGame = true;
    	mazeWriter = true; // set the second player to join a game to be the maze writer, not the maze traverser
    	document.getElementById("room-name").innerHTML="Get your Maze On, Δrchitect!<br/><i>You have two minutes to draw a maze that takes me one minute to solve.</i> <br/> You're in room: " +room;
    });

    socket.on('startGamePathFinder', function(room) {
    	clearCanvas();
    	inGame = true;
    	mouseDown = false;
    	mazeWriter = false;
   		document.getElementById("canvas-container").style.cursor='none';
   		document.getElementById("room-name").innerHTML="Light the way...PathFinder!  You are in room: "+room;
		old_xy = [];
    });

    socket.on('otherPlayerDisconnect',function(log) {
    	inGame = false;
	});

    socket.on('drawLine',function(coord) {
    	 drawLine(coord.x1,coord.y1,coord.x2,coord.y2, 'red');
    	//drawPoint(coord.x2,coord.y2,'red');
    });

    socket.on('drawMazeLine',function(line) {
    	 drawLine(line.x1,line.y1,line.x2,line.y2, 'black');
    });

    socket.on('drawPathLine',function(line) {
    	 drawLine(line.x1,line.y1,line.x2,line.y2, 'green');
    });

    function remove(id){
	    return (elem=document.getElementById(id)).parentNode.removeChild(elem);
	}

    socket.on('mazeComplete',function() {
    	if(!mazeWriter){
    		alert('You finished the maze, congrats!  Close your window to disconnect or refresh to enter a new game.  MazeOn, Path Finder!');
    	}else{
    		alert('They finished!');
    	}
    	remove("block1");
		remove("block2");
		remove("block3");
		remove("block4");
    });

    socket.on('consoleLog',function(log) {
		console.log(log);
	});

  });
</script>



</head>

<body>
	<h1>Δmaze Amaze</h1>
	<h2 id="room-name"></h2>
	<div id="mouseCoord">Mouse Coordinates position will be displayed here.</div>
	<br/>
	<div id="canvas-container" class="shadow">
		<canvas id="can" width="600" height="600"></canvas>
		<div id="startingBlock">ENTER</div>
		<div id="block1" > </div>
		<div id="block2" > </div>
		<div id="block3" > </div>
		<div id="block4" > </div>
		<div id="endBlock">EXIT</div>
 
	</div>
	<ul class="control-buttons">
		<li>
			<button class="punch" onclick="setMode('drag') ">Curvey</button> 
		</li>
		<li>
			<button class="punch" onclick="setMode('line') ">Line</button>
		</li>
	</ul>
	<div class="bottom-spacer"></div>



<script type="text/javascript">
//Canvas Code: BEGIN
{

	var canWidth = 600;
	var canHeight = canWidth;
	var slitWidth = 30;
	var slitHeight = slitWidth;

	function clipper(point){
		var obj=document.getElementById("block1");
		obj.style.height=point.y - slitHeight;

		var obj=document.getElementById("block2");
		obj.style.width=(canWidth - point.x) - slitWidth;

		var obj=document.getElementById("block3");
		obj.style.height=(canHeight - point.y) - slitHeight;

		var obj=document.getElementById("block4");
		obj.style.width= point.x - slitWidth;

	}

	// hide canvase http://robertnyman.com/2011/07/26/using-the-html5-canvas-clip-method-to-hide-certain-content/
	var canvas = document.getElementById('can');
	var clipPoint;
	function drawLine(x1,y1,x2,y2,color){
		if(canvas.getContext){
			var ctx = canvas.getContext('2d');
			ctx.strokeStyle=color;
			ctx.beginPath();
			ctx.moveTo(x1,y1);
			ctx.lineTo(x2,y2);
			ctx.stroke();
		}
	}

	function drawPoint(x,y,color){
		if(canvas.getContext){
			var ctx = canvas.getContext('2d');
			ctx.strokeStyle=color;
			ctx.beginPath();
			dot(ctx,x,y,3,color);
			ctx.stroke();
		}
	}

	function dot(ctx,x,y,rad,color){
		ctx.arc(x,y,rad,0,2*Math.PI,false);
		ctx.fillStyle=color;
		ctx.fill();
	}

	function clearCanvas(){
		if(canvas.getContext){
			var ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}
	}
}
//Canvas Code: END

//Mouse Events and Sending Lines: BEGIN
{
	var isMouseDown = false;
	var inputMode = mazeWriter? 'line' : 'drag'; //'drag'||'line'
	var firstPoint = {};
	var pathStarted = false;

	document.onmousedown=mouseDown;
	document.onmouseup=mouseUp;
	document.onmousemove=mouseMove;

	document.getElementById("startingBlock").onmousedown=onStartingBlock;
	document.getElementById("endBlock").onmousemove=onExit;

	function onStartingBlock(){
		if(!mazeWriter && !pathStarted){
			pathStarted = true;
		}
	};

	function onExit(){
		// This needs to be handled by server
		// if(!mazeWriter && pathStarted){
		// 	alert('You finished the maze, congrats!  Close your window to disconnect or refresh to enter a new game.  MazeOn, Path Finder!');
		// }
		if(mazeWriter){
			alert("Stop messing around and get started on the green Starting Block!");
		}
	};

	function mouseDown() {
		//console.log('mousedown!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
		firstPoint = getPoint();
		isMouseDown = true;
	}
	function mouseMove(){
		if(mazeWriter || pathStarted){
			if(inputMode != 'line'){
				if(!mazeWriter || isMouseDown){
					sendLine();	
				}
				//console.log(firstPoint);
				if(isMouseDown){
					firstPoint = getPoint();//this cannot happen before sendLine is called!
				}
			}
		}	
		if(!mazeWriter && inGame){
			clipper(getPoint());
		}
	}
	function mouseUp() {
		if(mazeWriter) { //nothing should ever change on mouseup for mazeSolver
			//console.log('I am the mazeWriter firstPoint = ',firstPoint);
			
			socket.emit('endLine', {name:name}); // this may be superfluous if always in line mode for mazeWriter...UPDATE: turns out this is not superfluous it is needed when the end of a mazemaker line is not valid. (this happens less often because in order for the mazeWriter to have collision they need to keep drawing after the pathfinder has started and intersect one of their lines.)
			
			sendLine('end');
			firstPoint = {};//this cannot happen before sendLine() is called!
			console.log(' firstPoint = ',firstPoint);
			isMouseDown = false;

		}
	}

	function setMode(mode) {
		if(mazeWriter){
			inputMode = mode;
			alert('input mode has been set to'+ mode);
		}
		else{
			alert('you are not the MazeMaker, No cheating! ')
		}
	}

	// from quirksmode.org/js/findpos.html start
	function findPos(obj) {
		var curleft = curtop = 0;
		if (obj.offsetParent) {
			do {
				curleft += obj.offsetLeft;
				curtop += obj.offsetTop;
			} while (obj = obj.offsetParent);
		}
		return {x:curleft,y:curtop};
	}
	// from quirksmode.org/js/findpos.html end

	function getPoint() {
			ev = window.event;
			document.getElementById("mouseCoord").innerHTML = "Mouse X:"+ev.pageX + " Mouse Y:"+ev.pageY;
			var canvas = document.getElementById('can');
			var canvasOffSet = findPos(canvas); 

			var x = ev.pageX - canvasOffSet.x;
			var y = ev.pageY - canvasOffSet.y;
			return {x:x, y:y};
	}

	function sendLine(end){
		if(inGame){
			var secondPoint = getPoint();
			socket.emit('sendLine',{x1:firstPoint.x, y1:firstPoint.y, x2: secondPoint.x, y2:secondPoint.y, n:name, end:end});
			//console.log({x1:firstPoint.x, y1:firstPoint.y, x2: secondPoint.x, y2:secondPoint.y, n:name, end:end});
			//console.log(firstPoint,secondPoint);
			//drawLine(firstPoint.x,firstPoint.y,secondPoint.x,secondPoint.y,'purple'); // this should be commented out for now it lets you see the path that the mouse takes when out of bounds.
		}
	}
}
//Mouse Events and Sending Lines: END

</script>
</body>
</html>